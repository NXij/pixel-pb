<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark" />
    <title>Pixel Uecapa pb Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/protobufjs/7.4.0/protobuf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            color-scheme: light dark;
            --darker-grey: #121212;
            --dark-grey: #333;
            --less-dark-grey: #282828;
            --grey: #474747;
            
            --white: #c0c0c0;
            --offwhite: #ddd;
            --lightred: #ff9fac;
            --darkred: red;
            --blue: #0c68bf;
        }

        body { font-family: Arial, sans-serif; margin: 0px; background-color: light-dark(var(--white), var(--darker-grey)); }
        table { border-collapse: collapse; margin: auto; }
        th, td { border: 1px solid light-dark(var(--offwhite), var(--grey)); padding: 0px 4px; text-align: left; }
        button { margin: 0px; background-color: light-dark(var(--offwhite), #474747);}
        select { background-color: light-dark(var(--offwhite), var(--grey));}
        input[type='text'] { background-color: light-dark(var(--offwhite), #474747);}
        input[type='number'] { background-color: light-dark(var(--offwhite), #474747)}
        .band-input { width: 60px; }
        h3, h4 { color: var(--white), var(--dark-grey)}

        @media (prefers-color-scheme: light) {
            button, select, input::file-selector-button, input[type='text'] {
                border-bottom: 1px solid black;
                border-right: 1px solid black;
                border-top: 1px solid white;
                border-left: 1px solid white;
            }
            button:active:hover {
                border-bottom: 1px solid white;
                border-right: 1px solid white;
                border-top: 1px solid black;
                border-left: 1px solid black;
            }
        }

        @media (prefers-color-scheme: dark) {
            button, select, input::file-selector-button, input[type='text'], input[type='number'] {
                border: 0;
            }
            button:hover:enabled {
                background-color: #666;
                cursor: pointer;
            }
            button:active:hover {
                background-color: #2b2b2b;
                cursor: pointer;
            }
        }
        /* Modal styles */
        .modalbtn { float: right; cursor: pointer; margin: 5px; }
        .main-table th, .main-table td
         {
            border: 1px solid light-dark(var(--offwhite), var(--less-dark-grey));
            padding: 3px;
            font-size: 14px;
            
        }
        .combo-table {
            
            border: 0px;
        }
        .band-input {
            width: 45px;
        }

        .header {
            display: flex;
            align-items: center;
            position: fixed;
            background-color: light-dark(var(--blue), var(--dark-grey));
            width: 100%;
            justify-content: space-evenly;
            color: light-dark(white, white);
        }
        .buttons {
            display: flex;
            flex-direction: column;
        }
        #tableContainer {
            padding-top: 24px;
        }
        .btn-json {
            margin-bottom: 5px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: #00000066;
        }
        .modal-content {
            background-color: light-dark(var(--white), var(--dark-grey));
            margin: 6% auto;
            padding: 20px;
            padding-bottom: 60px;
            border: 1px solid light-dark(var(--grey), var(--grey));
            width: 30%;
            max-height: 70vh; /* Set maximum height to 70% of viewport height */
        }
        #customFeatureModal .modal-content h3, #customFeatureModal .modal-content h4 {
            margin-top: 0;
        }
        #customFeatureModal .modal-content label {
            display: inline-block;
            width: 150px;
            margin-bottom: 5px;
        }

        #jsonOutput {
            max-height: calc(70vh - 220px); /* Account for padding and close button */
            overflow-y: auto; /* Enable vertical scrolling */
            margin: 0;
            margin-bottom: 18px;
            white-space: pre-wrap; /* Preserve formatting while allowing wrapping */
        }
        #jsonheaderOutput, #jsonOutput {
            background-color: light-dark(var(--offwhite), var(--grey));
        }
        .btn-copy {
            margin-bottom: 5px;
            color: light-dark(var(--blue), #8bb7f0);
        }
        .btn-rem {
            color: light-dark(var(--darkred), var(--lightred));
        }
        .color-row {
            background-color: light-dark(#aaa, #212121) !important;
        }
        .binarypbInfo {
            margin: 5px;
            font-size: 14px;
            display: flex;
            justify-content: space-evenly;
        }
        .groupheader {
            color: #666;
            padding: 0px;
            display: flex;
            justify-content: right;
            font-size: 10px;
            margin: -2px 2px 0px 0px;
        }
        .groupheader input {
            background-color: unset;
            font-size: 10px;
            width: 50px;
            margin: -1px 3px;
        }
        .fsaddbtn {
            width: 100%;
        }
        .combodirind {
            display: none !important;
        }
        @media (max-width: 768px) {

            .main-table {
                width: 100%;
            }
            .binarypbInfo {
                margin-top: 80px;
                flex-direction: column;
                align-items: stretch; /* Stretch items to full width */
                height: auto; /* Let height be determined by content */
            }
            #infoFeatureSets, #infoPatches {
                display: flex;
                flex-wrap: wrap;
                align-items: center;
            }
            .header {
                flex-direction: column;
                align-items: stretch; /* Stretch items to full width */
                position: absolute; /* Change from fixed to allow scrolling with page */
                height: auto; /* Let height be determined by content */
            }
            #bandFilter {
                order: 1; /* Attempt to move pagination up if needed or style differently */
                display: flex;
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
                position: fixed;
                bottom: env(safe-area-inset-bottom);
                background: var(--grey);
            }
            #pagination {
                order: 1; /* Attempt to move pagination up if needed or style differently */
                display: flex;
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
                position: fixed;
                bottom: env(safe-area-inset-bottom);
                right: 0px;
                background: var(--grey);
            }
            #recompileBtn label {
                display: none;
            }
            #clearLocalStorageBtn {
                order: -3; /* Attempt to move pagination up if needed or style differently */
                width: 120px;
                padding: 0px;
            }
            .main-table th, .main-table td {
                font-size: 13px;
                padding: 8px 5px;
            }
            .main-table tr {
                border-bottom: 1px solid var(--grey);
            }
             .main-table th:first-child { /* "Filtered Combos" header */
                text-align: left;
            }
            .main-table th:nth-child(2) { /* "Actions" header */
                display: none; /* Hide actions header, buttons will be clear */
            }

            .main-table .combo-row {
                display: flex;
                flex-direction: column; /* Stack combo details and action buttons */
                border-bottom: 1px solid var(--grey);
                margin-bottom: 15px;
                padding-bottom: 10px;
            }
            .main-table .combo-row > td { /* Target direct children td of .combo-row */
                width: 100% !important; 
                box-sizing: border-box;
                padding: 5px 0;
            }
            .main-table .buttons { /* Container for JSON, Copy, Remove buttons */
                display: flex;
                flex-direction: row; 
                justify-content: space-between; 
                margin-top: 10px;
            }
            .main-table .buttons button {
                flex-grow: 1; 
                margin: 0 3px; 
                padding: 10px 5px;
                font-size: 13px;
            }

            .combo-table td {
                width: 100% !important; 
                padding: 8px 0; 
                border: none; 
                display: flex; 
                flex-wrap: wrap; 
                align-items: center; 
            }
            .combodirind {
            display: flex !important;
            }
            .bandextraind {
                display: none !important;
            }

                        /* --- Modals --- */
            .modal-content {
                width: 90%; 
                margin: 5% auto; 
                max-height: 85vh;
                padding: 15px;
                padding-bottom: 70px; /* Ensure space for buttons at bottom */
            }
            #jsonOutput, #jsonheaderOutput {
                font-size: 12px;
                max-height: calc(85vh - 180px); /* Adjusted for modal content */
            }
            #fsdirbtn {
                display: flex;
                justify-content: space-around;
                margin-bottom: 10px;
            }
            #fsdirbtn button {
                flex: 1;
                margin: 0 5px;
                padding: 10px;
            }
            .modalbtn { /* Apply, Cancel buttons in modal */
                padding: 10px 15px;
                font-size: 14px;
            }

            /* Custom Feature Modal specific */
            #customFeatureModal .modal-content > div[style*="display: flex; gap: 10px;"]:not([style*="justify-content: center"]) { /* The DL/UL columns container */
                flex-direction: column; /* Stack DL and UL sections */
                gap: 0; /* Remove gap, use margin on children */
            }
            #customFeatureModal .modal-content > div[style*="display: flex; gap: 10px;"]:not([style*="justify-content: center"]) > div {
                margin-bottom: 15px; /* Space between DL and UL sections */
            }

            #customFeatureModal .modal-content h3 {
                font-size: 18px;
                margin-bottom: 15px;
            }
            #customFeatureModal .modal-content h4 {
                font-size: 16px;
                margin-top: 10px;
                margin-bottom: 10px;
            }
            #customFeatureModal .modal-content label {
                display: block; /* Label on its own line */
                width: 100%;
                margin-bottom: 5px;
                font-weight: normal;
            }
            #customFeatureModal .modal-content input[type="number"],
            #customFeatureModal .modal-content select {
                width: 100%;
                box-sizing: border-box;
                margin-bottom: 12px;
                padding: 10px;
            }
            #customFeatureModal .modal-content input[type="checkbox"] {
                margin-bottom: 12px;
                margin-left: 5px; 
                transform: scale(1.2); /* Make checkbox slightly larger */
            }
             /* Container for "Add DL/UL Feature" buttons */
            #customFeatureModal .modal-content div[style*="justify-content: center"] {
                flex-direction: column; /* Stack Add DL/UL buttons */
                margin-top: 10px;
            }
            #customFeatureModal .modal-content {
                max-height: fit-content;
            }
            #customFeatureModal .modal-content .fsaddbtn {
                width: 100%; 
                margin-bottom: 10px; 
                padding: 12px;
            }
            #customFeatureModal .modal-content .fsaddbtn:last-child {
                margin-bottom: 0;
            }

            /* General Touch-ups for buttons and inputs */
            button, select, input[type='text'], input[type='number'], input[type='file']::file-selector-button {
                padding: 10px;
                font-size: 14px;
            }

        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <input type="file" title="Load a .binarybp uecapability file from a Pixel" id="fileInput" accept=".binarypb" />
            <div id="bandFilter" style="display: none;">
                <input type="text" id="bandFilterInput" placeholder="Filter e.g., 1+3+7c+n78c">
                <button onclick="bandFilter=''; bandFilterInput.value=''; generateTable(decodedData);">Clear</button>
            </div>
            
            <div id="pagination"></div>
            <div id="pageSizeSelector" style="display: none;">
                <label for="pageSizeDropdown">Per page:</label>
                <select id="pageSizeDropdown" onchange="changePageSize(this.value)">
                    <option value="20">20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
            <div id="recompileBtn" style="display: none;">
                <label for="filenameInput">Filename:</label>
                <input type="text" id="filenameInput" value="" onchange="updateFilename(this.value)">
                <button title="Download the compiled binarypb file" onclick="dlProtobuf()">↓ .binarypb</button>
                <button title="Download the generated Magisk zip"onclick="createZipWithSubdirectories()">↓ .zip</button>
            </div>
            <button id="clearLocalStorageBtn" title="Clear the stored session" onclick="clearLocalStorageAndReload()">Clear session</button>

            
        </div>
        <div id="tableContainer"></div>
        
    </div>

    <!-- Modal for showing raw JSON -->
    <div id="jsonModal" class="modal">
        <div class="modal-content">
            <pre id="jsonheaderOutput" spellcheck="false"></pre>
            <div id="fsdirbtn">
                <button onclick="editFeatureSets(1)">Downlink</button>
                <button onclick="editFeatureSets(2)">Uplink</button>
            </div>
            <pre id="jsonOutput" spellcheck="false" style="white-space: pre-wrap;"></pre>
            <button class="modalbtn" onclick="closeModal()">Cancel</button>
            <button class="modalbtn" id="savebtn" onclick="closeModal()">Apply</button>
        </div>
    </div>

    <!-- Modal for adding custom feature sets -->
    <div id="customFeatureModal" class="modal">
       <div class="modal-content">
            <h3>Add Custom Feature Sets</h3>
        
            <div style="display: flex; gap: 10px;">
                <!-- DL Feature Set -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div> <!-- Content wrapper for top elements -->
                        <h4>Downlink (DL) Feature Set</h4>
                        <label>Max SCS:</label>
                        <select id="dlMaxScs">
                            <option value="1">15kHz (1)</option>
                            <option value="2">30kHz (2)</option>
                            <option value="3">60kHz (3)</option>
                            <option value="4">120kHz (4)</option>
                            <option value="5">240kHz (5)</option>
                        </select><br><br>
                    
                        <label>Max MIMO:</label>
                        <select id="dlMaxMimo">
                            <option value="0">Not Supported</option>
                            <option value="1">2x2</option>
                            <option value="2">4x4</option>
                            <option value="3">8x8</option>
                        </select><br><br>
                    
                        <label>Max BW (MHz):</label>
                        <input type="number" id="dlMaxBw" value="100" min="0" max="1000"><br><br>
                    
                        <label>Max Mod Order:</label>
                        <select id="dlMaxModOrder">
                            <option value="0">Not Supported</option>
                            <option value="1">QAM64</option>
                            <option value="2">QAM256</option>
                        </select><br><br>
                    
                        <label>90MHz Support:</label>
                        <input type="checkbox" id="dlBw90MHz"><br><br>
                    </div>
                    <button class="fsaddbtn" onclick="addCustomDlFeature()" style="margin-top: auto;">Add DL Feature</button>
                </div>
                

                <!-- UL Feature Set -->
                <div style="flex: 1; display: flex; flex-direction: column;">
                    <div> <!-- Content wrapper for top elements -->
                        <h4>Uplink (UL) Feature Set</h4>
                        <label>Max SCS:</label>
                        <select id="ulMaxScs">
                            <option value="1">15kHz (1)</option>
                            <option value="2">30kHz (2)</option>
                            <option value="3">60kHz (3)</option>
                            <option value="4">120kHz (4)</option>
                            <option value="5">240kHz (5)</option>
                        </select><br><br>
                    
                        <label>Max MIMO CB:</label>
                        <select id="ulMaxMimoCb">
                            <option value="0">Not Supported</option>
                            <option value="1">No</option>
                            <option value="2">Yes</option>
                        </select><br><br>
                    
                        <label>Max BW (MHz):</label>
                        <input type="number" id="ulMaxBw" value="100" min="0" max="1000"><br><br>
                    
                        <label>Max Mod Order:</label>
                        <select id="ulMaxModOrder">
                            <option value="0">Not Supported</option>
                            <option value="1">QAM64</option>
                            <option value="2">QAM256</option>
                        </select><br><br>
                    
                        <label>90MHz Support:</label>
                        <input type="checkbox" id="ulBw90MHz"><br><br>
                    
                        <label>Max MIMO Non-CB:</label>
                        <input type="number" id="ulMaxMimoNonCb" value="0" min="0" max="10"><br><br>
                    </div>
                    <button class="fsaddbtn" onclick="addCustomUlFeature()" style="margin-top: auto;">Add UL Feature</button>
                </div>
            </div>
           
            <div style="margin-top: 20px; text-align: right;">
                <button class="modalbtn" onclick="closeCustomFeatureModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Proto definition
        const protoDefinition = `
            syntax = "proto3";

            message uecaps {
              uint32 version = 1;
              optional int32 id = 2;
              repeated ComboGroup ComboGroups = 3;
              repeated ShannonFeatureSetDlPerCCNr dlFeaturePerCCList = 6;
              repeated ShannonFeatureSetUlPerCCNr ulFeaturePerCCList = 7;
              optional uint32 unknown = 9;
            }

            message ComboGroup {
              message Nested1 {
                optional uint32 bcsNr = 1;
                optional uint32 bcsIntraEndc = 2;
                optional uint32 bcsEutra = 3;
                optional int32 powerClass = 4;
                optional int32 intraBandEnDcSupport = 5;
              }
              message Nested2 {
                message ComboFeatures {
                  int32 band = 1;
                  optional int32 bwClassDL = 2;
                  optional int32 bwClassUL = 3;
                  optional int32 dlFeatureIndex = 4;
                  optional int32 ulFeatureIndex = 5;
                  optional bytes dlFeaturePerCCIds = 6;
                  optional bytes ulFeaturePerCCIds = 7;
                  optional int32 srstxswitch = 8;
                }
                repeated ComboFeatures cc = 1;
                int32 bitMask = 2;
              }

              Nested1 combo_header = 1;
              repeated Nested2 combo = 2;
            }

            message ShannonFeatureSetDlPerCCNr {
              optional int32 maxScs = 1;
              optional int32 maxMimo = 2;
              optional int32 maxBw = 3;
              optional int32 maxModOrder = 4;
              optional bool bw90MHzSupported = 5;
            }

            message ShannonFeatureSetUlPerCCNr {
              optional int32 maxScs = 1;
              optional int32 maxMimoCb = 2;
              optional int32 maxBw = 3;
              optional int32 maxModOrder = 4;
              optional bool bw90MHzSupported = 5;
              optional int32 maxMimoNonCb = 6;
            }
        `;

        const root = protobuf.parse(protoDefinition).root;
        const UeCaps = root.lookupType("uecaps");

        // Proto helper functions
        function decodeBase64ToBytes(base64Str) {
            const binaryString = atob(base64Str);
            return new Uint8Array([...binaryString].map(char => char.charCodeAt(0)));
        }

        function processDecodedMessage(obj) {
            for (let key in obj) {
                if (typeof obj[key] === "string" && obj[key].match(/^[A-Za-z0-9+/=]+$/)) {
                    try {
                        const decodedBytes = decodeBase64ToBytes(obj[key]);
                        obj[key] = Array.from(decodedBytes);
                    } catch (e) {
                        // If decoding fails, leave the original value
                    }
                } else if (typeof obj[key] === "object" && obj[key] !== null) {
                    processDecodedMessage(obj[key]);
                }
            }
        }

        // Close json modal on background click
        window.onmousedown = function(event) {
            const jsonModal = document.getElementById('jsonModal');
            const customFeatureModal = document.getElementById('customFeatureModal');
    
            if (event.target === jsonModal) {
                closeModal();
            } else if (event.target === customFeatureModal) {
                closeCustomFeatureModal();
            }
        };
        // Close json modal on esc
        document.addEventListener("keydown", function(event) {
            if (event.key === "Escape") {
                closeModal();
                closeCustomFeatureModal();
            }
        });

        function getCookie(name) {
            let match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
            return match ? decodeURIComponent(match[2]) : null;
        }

        // Generate integrit and filename save/restore buttons
        function integrityCookieStoreButtons() {
            let html = "";
            
            html += `<button title="Restore integrity and filename from cookies" id="restoreIntegrity" ${(!getCookie("storedintegrity")) ? `style="display: none"` : ""} onclick="restoreIntegrityCookie()">Restore</button>`;
            html += `<button title="Save current integrity and filename to a cookie" onclick="saveIntegrityCookie()">Save</button>`;
            
            return html;
        }

        function saveIntegrityCookie() {
            if (typeof decodedData !== 'undefined' && decodedData.unknown) {
                
                // Store cookies for 365 days
                document.cookie = `storedfilename=${originalFilename}; Max-Age=31536000; path=/`;
                document.cookie = `storedintegrity=${decodedData.unknown}; Max-Age=31536000; path=/`;

                // Unhide restore button on save
                document.getElementById("restoreIntegrity").style.display = "unset";
            } else {
                console.log("saveIntegrityCookie failure");
            }
        }

        function restoreIntegrityCookie() {
            let integrity = getCookie("storedintegrity");
            let filename = getCookie("storedfilename");
            
            if (integrity) {
                decodedData.unknown = integrity;
                originalFilename = filename;

                document.getElementById("integrityField").value = integrity;
                document.getElementById("filenameInput").value = filename;
            }
        }

        function copyCombo(realGroupIndex, localComboIndex) {
            // Get the combo to copy
            let groupToCopy = decodedData.ComboGroups[realGroupIndex];
            let comboToCopy = groupToCopy.combo[localComboIndex];
            let comboHeaderToCopy = groupToCopy.comboHeader;
            // Create deep copies to avoid reference issues
            let newComboHeader = JSON.parse(JSON.stringify(comboHeaderToCopy));
            let newCombo = JSON.parse(JSON.stringify(comboToCopy));
            // Process the Uint8Arrays in the cc items properly
            newCombo.cc.forEach((ccItem) => {
                // Handle dlFeaturePerCCIds
                if(ccItem.dlFeaturePerCCIds && typeof ccItem.dlFeaturePerCCIds === 'object') {
                    const dlValues = Object.values(ccItem.dlFeaturePerCCIds);
                    ccItem.dlFeaturePerCCIds = new Uint8Array(dlValues);
                }
                // Handle ulFeaturePerCCIds
                if(ccItem.ulFeaturePerCCIds && typeof ccItem.ulFeaturePerCCIds === 'object') {
                    const ulValues = Object.values(ccItem.ulFeaturePerCCIds);
                    ccItem.ulFeaturePerCCIds = new Uint8Array(ulValues);
                }
            });
            // Add the new combo to the beginning of the ComboGroups array
            decodedData.ComboGroups.unshift({
                comboHeader: newComboHeader,
                combo: [newCombo]
            });
            generateTable(decodedData);
        }

        // Function to update band number
        function updateBand(realGroupIndex, localComboIndex, ccIndex, newValue) {
            let oldBand = decodedData.ComboGroups[realGroupIndex].combo[localComboIndex].cc[ccIndex].band;
            let newBandData = bandParseStr(newValue);
            let newBand = newBandData.band;
            let count = newBandData.bwClassDL;
    
            // Determine if this is a band type change (NR <-> LTE)
            let oldIsNR = oldBand > 10000;
            let newIsNR = newBand > 10000;
            let bandTypeChanged = oldIsNR !== newIsNR;
    
            console.log(`Updated band:${newBand} cc:${count}, type changed: ${bandTypeChanged}`);
    
            let ccItem = decodedData.ComboGroups[realGroupIndex].combo[localComboIndex].cc[ccIndex];
            ccItem.band = Number(newBand);
            ccItem.bwClassDL = count;
    
            // If band type changed, reset all feature-related values
            if (bandTypeChanged) {
                delete ccItem.dlFeaturePerCCIds;
                delete ccItem.ulFeaturePerCCIds;
        
                ccItem.dlFeatureIndex = 0;
                ccItem.ulFeatureIndex = 0;
                ccItem.bwClassUL = 0;
        
                // Initialize appropriate feature arrays for the new band type
                if (newIsNR) {
                    ccItem.dlFeaturePerCCIds = new Uint8Array(0);
                    ccItem.ulFeaturePerCCIds = new Uint8Array(0);
                } else {
                    // For LTE bands, remove the Uint8Array properties entirely
                    // They will be recreated when features are added
                }
        
                console.log(`Band type changed from ${oldIsNR ? 'NR' : 'LTE'} to ${newIsNR ? 'NR' : 'LTE'}, features reset`);
            }
    
            generateTable(decodedData);
        }

        // Modified generate table function to include editable band numbers
        let currentPage = 1;
        let rowsPerPage = 20;
        let bandFilter = "";
        let filteredGroups = [];
        let globalIndexMap = []; // Stores correct indices after filtering & pagination

        function changePageSize(newSize) {
            rowsPerPage = parseInt(newSize, 10);
            currentPage = 1; // Reset to first page when changing page size
            generateTable(decodedData);
        }

        function generateTable(decodedData) {
            filteredGroups = applyBandFilter(decodedData.ComboGroups);
            let totalRows = filteredGroups.length;
            let totalPages = Math.ceil(totalRows / rowsPerPage);

            let start = (currentPage - 1) * rowsPerPage;
            let end = start + rowsPerPage;

            let tableHTML = `<div class="binarypbInfo"><span>ID: ${decodedData.id} | Version: ${decodedData.version} | Integrity:
                <input type="text" id="integrityField" value="${decodedData.unknown}" oninput="decodedData.unknown = this.value">
                ${integrityCookieStoreButtons()}
                </span>
                <div>
                <span id="infoFeatureSets">FeatureSets:
                    <button title="Add custom DL/UL feature sets" onclick="showCustomFeatureModal()">Add</button>
                    <button title="Edit available FeatureSets" id="editFeatureSetsBtn" onclick="editFeatureSets(1)">JSON</button>
                    </span>
                <span id="infoPatches">Patches:
                    <button title="65k patch is useful on Pixel 7/8 series for allowing all bands. On Pixel 9 series this is always 0." id="bitMaskToggleBtn" onclick="toggleBitMask()">Apply BM 65k patch</button>
                    <button title="Integrity field is present on some .binarypbs, it has to match the same value as your currently active binarypb on your phone." id="toggleIntegrityBtn" onclick="toggleIntegrity()">Integrity ${decodedData.hasOwnProperty('unknown') ? "OFF" : "ON"}</button>
                    </span>
                </div></div>
            <table class="main-table" style="border-collapse: collapse;">
                <tr>
                    <th><button title="Add a new combo" onclick="addNewComboToFirstGroup()">+</button> Filtered Combos: ${countCombos(filteredGroups)}/${countCombos(decodedData.ComboGroups)}</th>
                    <th>Actions</th>
                </tr>`;

            if (currentPage > totalPages) {
                currentPage = 1;
                start = 0;
                end = rowsPerPage;
            }

            let paginatedGroups = filteredGroups.slice(start, end);
            globalIndexMap = filteredGroups.map(group => decodedData.ComboGroups.indexOf(group)); // Map to real indices

            paginatedGroups.forEach((group, localGroupIndex) => {
                let realGroupIndex = globalIndexMap[start + localGroupIndex]; // Map local to real index

                group.combo.forEach((combo, localComboIndex) => {
                    let innerTableHTML = `<table class="combo-table" style="width: 100%; border-collapse: collapse;">
                        <div class="groupheader">
                            <span>bcsNr:</span>
                            <input type="text" name="bcsNr" value="${parseBcs(group.comboHeader.bcsNr)}" oninput="updateBcs(${realGroupIndex},this.value,'bcsNr')">
                            <span>bcsEutra:</span>
                            <input type="text" name="bcsEutra" value="${parseBcs(group.comboHeader.bcsEutra)}" oninput="updateBcs(${realGroupIndex},this.value,'bcsEutra')">
                            <span>PC:</span>
                            <input type="text" name="powerClass" value="${group.comboHeader.powerClass}" oninput="updateComboHeader(${realGroupIndex},this.value,'powerClass')">
                            <span>intraEndc:</span>
                            <input type="text" name="intraBandEnDcSupport" value="${group.comboHeader.intraBandEnDcSupport}" oninput="updateComboHeader(${realGroupIndex},this.value,'intraBandEnDcSupport')">
                        </div>`;

                    combo.cc.forEach((ccItem, ccIndex) => {
                        let hasUlFeature = ccItem.ulFeaturePerCCIds && Object.keys(ccItem.ulFeaturePerCCIds).length > 0;

                        // 0 is NR, 1 is LTE (Later on LTE DL = 1, LTE UL = 2)
                        let ran = (ccItem.band > 10000) ? 0 : 1;
                        let rowClass = hasUlFeature ? "color-row" : ""; // Apply class if ulFeaturePerCCIds exists

                        let bandInput = `<input name="band-input" type="text" class="band-input" value="${bandParseInt(ccItem.bwClassDL,ccItem.band)}"
                            onchange="updateBand(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, this.value)" />`;

                        // Show "+" button only for the last band input
                        let addBandBtn = ccIndex === combo.cc.length - 1
                            ? `<button onclick="addBand(${realGroupIndex}, ${localComboIndex})">+</button>`
                            : "";

                        let removeBandBtn = `<button onclick="removeBand(${realGroupIndex}, ${localComboIndex}, ${ccIndex})">-</button>`;

                        let dlFeaturePerCCIdsHTML = '';
                        let ulFeaturePerCCIdsHTML = '';

                        // Handle nr
                        if (ran === 0) {
                            // DL Feature Per CC IDs
                            const dlKeys = Object.keys(ccItem.dlFeaturePerCCIds || {});
                            dlKeys.forEach((key, index) => {
                                let value = ccItem.dlFeaturePerCCIds[key] || 0;
                                dlFeaturePerCCIdsHTML += `
                                    <select name="FeatureId" onchange="updateFeatureId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'dlFeaturePerCCIds.${key}', this.value, ${ran})">
                                        ${createDropdownOptions(decodedData.dlFeaturePerCCList, value, ran)}
                                    </select>
                                    <button onclick="removeFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'dlFeaturePerCCIds', ${ran})">-</button>`;
                                // Only add line break if it's not the last item
                                if (index < dlKeys.length - 1) {
                                    dlFeaturePerCCIdsHTML += '<br>';
                                }
                            });
                            // Add the + button inline with the last item
                            dlFeaturePerCCIdsHTML += `<button onclick="addFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'dlFeaturePerCCIds', ${ran})">+</button>`;

                            // UL Feature Per CC IDs
                            if (ccItem.ulFeaturePerCCIds && typeof ccItem.ulFeaturePerCCIds === "object") {
                                const ulKeys = Object.keys(ccItem.ulFeaturePerCCIds);
                                ulKeys.forEach((key, index) => {
                                    let value = ccItem.ulFeaturePerCCIds[key] || 0;
                                    ulFeaturePerCCIdsHTML += `
                                        <select name="FeatureId" onchange="updateFeatureId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'ulFeaturePerCCIds.${key}', this.value, ${ran})">
                                            ${createDropdownOptions(decodedData.ulFeaturePerCCList, value, ran)}
                                        </select>
                                        <button onclick="removeFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'ulFeaturePerCCIds', ${ran})">-</button>`;
                                    // Only add line break if it's not the last item
                                    if (index < ulKeys.length - 1) {
                                        ulFeaturePerCCIdsHTML += '<br>';
                                    }
                                });
                                // Add the + button inline with the last item
                                ulFeaturePerCCIdsHTML += `<button onclick="addFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'ulFeaturePerCCIds', ${ran})">+</button>`;
                            } else {
                                // If no UL features exist, just show the + button
                                ulFeaturePerCCIdsHTML = `<button onclick="addFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'ulFeaturePerCCIds', ${ran})">+</button>`;
                            }
                        // Handle lte
                        } else if (ran === 1) {
                            // LTE DL
                            const dlKeys = Object.keys(ccItem.dlFeaturePerCCIds || {});
                            let mimoList = ["None", "4x4", "2x2", "2+4", "4+2"];
                            if (dlKeys.length > 0) {
                                dlFeaturePerCCIdsHTML = `
                                <select name="FeatureId" onchange="updateFeatureId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 0, this.value, ${ran})">
                                    ${createDropdownOptions(mimoList, parseLteFeatureIndex({ FeatureIndex: ccItem.dlFeatureIndex, ran: ran }).mimo, ran)}
                                </select>
                                <button class="bwInd">${String.fromCharCode(64 + ccItem.bwClassDL)}</button>
                                <button onclick="removeFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'dlFeaturePerCCIds', ${ran})">-</button>`;
                            }

                            dlFeaturePerCCIdsHTML += `
                                <button onclick="addFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'dlFeaturePerCCIds', ${ran})">+</button>`;

                            // LTE UL
                            const ulKeys = Object.keys(ccItem.ulFeaturePerCCIds || {});
                            ran = 2;
                            let mimoListUl = ["None", "2x2", "1x1"];
                            if (ulKeys.length > 0) {
                            ulFeaturePerCCIdsHTML = `
                                <select name="FeatureId" onchange="updateFeatureId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 1, this.value, ${ran})">
                                    ${createDropdownOptions(mimoListUl, parseLteFeatureIndex({ FeatureIndex: ccItem.ulFeatureIndex, ran: ran }).mimo, ran)}
                                </select>
                                <button class="bwInd">${String.fromCharCode(64 + ccItem.bwClassUL)}</button>
                                <button onclick="removeFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'ulFeaturePerCCIds', ${ran})">-</button>`;
                            }
                            ulFeaturePerCCIdsHTML += `
                                <button onclick="addFeaturePerCCId(${realGroupIndex}, ${localComboIndex}, ${ccIndex}, 'ulFeaturePerCCIds', ${ran})">+</button>`;
                        }

                        innerTableHTML += `<tr class="${rowClass}">
                            <td width="100">${bandInput} ${removeBandBtn} ${addBandBtn}</td>
                            <td class="bandextraind" width="40">${ccItem.bwClassDL}/${ccItem.bwClassUL}</td>
                            <td class="bandextraind" width="30">${ccItem.dlFeatureIndex}/${ccItem.ulFeatureIndex}</td>
                            <td class="combodirind"><span class="groupheader">DL</span></td>
                            <td width="500" >${dlFeaturePerCCIdsHTML}</td>
                            <td class="combodirind"><span class="groupheader">UL</span></td>
                            <td>${ulFeaturePerCCIdsHTML}</td>
                        </tr>`;
                    });

                    innerTableHTML += '</table>';

                    tableHTML += `<tr class="combo-row">
                        <td>${innerTableHTML}</td>
                        <td class="buttons">
                            <button title="Edit this combo in json" class="btn-json"onclick="showJSON(${realGroupIndex}, ${localComboIndex})">JSON</button>
                            <button title="Copy this combo" class="btn-copy" onclick="copyCombo(${realGroupIndex}, ${localComboIndex})">Copy</button>
                            <button title="Remove this combo" class="btn-rem" onclick="removeCombo(${realGroupIndex}, ${localComboIndex})">Remove</button>
                        </td>
                    </tr>`;
                });
            });

            updatePaginationControls(totalPages);
            tableHTML += `</table>`;
            document.getElementById("tableContainer").innerHTML = tableHTML;
            document.getElementById("recompileBtn").style.display = "block";
            document.getElementById("bandFilter").style.display = "block";
            document.getElementById("pageSizeSelector").style.display = "block";
        }

        function parseBcs(value) {
            // Convert to a 32-bit binary string, padding with leading zeros if necessary
            let binaryString = (value >>> 0).toString(2).padStart(32, '0');
            const indexes = [];

            // Iterate through the binary string to find positions of "1"
            for (let i = 0; i < binaryString.length; i++) {
                if (binaryString[i] === "1") {
                    indexes.push(i);
                }
            }

            return indexes;
        }

        function updateBcs(realGroupIndex, indexes, type, length = 32) {
            // If indexes is a string, convert it to an array of numbers
            if (typeof indexes === "string") {
                indexes = indexes.split(",").map(num => parseInt(num.trim(), 10));
            }

            if (!Array.isArray(indexes)) {
                console.error("Expected an array or a comma-separated string, received:", indexes);
                return null;
            }

            let binaryArray = new Array(length).fill("0");
            indexes.forEach(index => {
                if (!isNaN(index) && index < length) {
                    binaryArray[index] = "1";
                }
            });
            let value = parseInt(binaryArray.join(""), 2);
            decodedData.ComboGroups[realGroupIndex].comboHeader[type] = value;
        }

        function updateComboHeader(realGroupIndex, value, field) {
            let numValue = parseInt(value, 10);
            if (isNaN(numValue)) {
                numValue = 0;
            }
            decodedData.ComboGroups[realGroupIndex].comboHeader[field] = numValue;
            console.log(`Updated ${field} to ${numValue} for group ${realGroupIndex}`);
        }

        function parseLteFeatureIndex({ FeatureIndex = null, mimo = null, count = null, ran }) {
            // Account for C class being 2cc not 3
            count === 3 && (count = 2);

            if (FeatureIndex !== null) {

                // Convert FeatureIndex to mimo and count
                if (ran === 1) {
                    if (FeatureIndex === 0) return { mimo: 0, count: 0 };
                    count = Math.ceil(FeatureIndex / 2); // Determine count

                    if (FeatureIndex === 5) mimo = 3; // Special case: One 2x2 + One 4x4
                    else if (FeatureIndex === 6) mimo = 4; // Special case: One 4x4 + One 2x2
                    else mimo = FeatureIndex % 2 === 0 ? 2 : 1; // Even = 4x4 (2), Odd = 2x2 (1)
                } else if (ran === 2) {
                    // Make 1x1 default since 2x2 does not seem to work for LTE anyways
                    mimo = (FeatureIndex === 1) ? 1 : 2;
                    count = (FeatureIndex === 0) ? 0 : count;
                }

            } else if (mimo !== null && count !== null) {
                if (ran === 1) {
                    // Convert mimo & count to FeatureIndex
                    if (mimo === 0 && count === 0) return { FeatureIndex: 0 };
                    if (mimo === 3 && count === 2) return { FeatureIndex: 5 }; // Special case
                    if (mimo === 4 && count === 2) return { FeatureIndex: 6 }; // Special case

                    FeatureIndex = (count - 1) * 2 + (mimo === 2 ? 2 : 1);
                } else if (ran === 2) {
                    (count > 0) ? FeatureIndex = mimo : FeatureIndex = 0;
                    
                }

            } else {
                throw new Error("Invalid input: Provide either FeatureIndex OR both mimo & count.");
            }

            return { FeatureIndex, mimo, count };
        }

        function countCombos(groups) {
            return groups.reduce((sum, group) => sum + group.combo.length, 0);
        }
        
        function bandParseInt(bwClassDL, Band) {
            let bwClass = "";
            // Convert band number
            if (Band > 10000) {
                Band = "n" + (Band - 10000);
            }

            // 64 is A, 65 B and so on...
            if (bwClassDL > 0) {
                bwClass = String.fromCharCode(64 + bwClassDL);
            }
            
            return Band+bwClass; // Return formatted string
        }
        

        function bandParseStr(Band) {
            let bandNum = Band.match(/\d+/); // Extract the numeric part
            let bwClass = Band.match(/[a-zA-Z]$/); // Extract the classification letter (A-I or a-i)

            if (!bandNum) return Band; // If no valid band number, return as is

            bandNum = Number(bandNum[0]); // Convert extracted number to integer

            if (Band.startsWith("n")) {
                bandNum += 10000; // Convert n78 → 10078
            }

            // Convert 'A' → 1, 'B' → 2, ..., and handle both uppercase and lowercase letters
            let bwClassDL = bwClass ? bwClass[0].toUpperCase().charCodeAt(0) - 64 : 0; // Convert 'a' → 1, 'b' → 2, etc.
            
            return { band: bandNum, bwClassDL };
        }

        function addNewComboToFirstGroup() {
            let newComboHeader = {
                "bcsNr": 0,
                "bcsEutra": 0,
                "powerClass": 0,
                "intraBandEnDcSupport": 0
            };

            let newCombo = {
                "cc": [
                    {
                        "band": 10078,
                        "bwClassDL": 0,
                        "bwClassUL": 0,
                        "dlFeatureIndex": 0,
                        "ulFeatureIndex": 0,
                    }
                ],
                "bitMask": 0
            };

            // Insert new combo at the first position and shift other groups forward
            decodedData.ComboGroups.unshift({
                comboHeader: newComboHeader,
                combo: [newCombo]
            });

            generateTable(decodedData); // Refresh the table

            console.log("New combo added to group 0");
        }

        function addBand(groupIndex, comboIndex) {
            let newBand = {
                band: 10078,
                bwClassDL: 0,
                bwClassUL: 0,
                dlFeatureIndex: 0,
                ulFeatureIndex: 0,
            };

            decodedData.ComboGroups[groupIndex].combo[comboIndex].cc.push(newBand);
            //console.log("After Adding Band:", JSON.stringify(decodedData, null, 2));

            generateTable(decodedData);
        }

        function removeBand(realGroupIndex, localComboIndex, ccIndex) {
            let combo = decodedData.ComboGroups[realGroupIndex].combo[localComboIndex];

            if (combo.cc.length > 1) {
                combo.cc.splice(ccIndex, 1);
            } else {
                alert("At least one band must be present in the combo.");
            }
            console.log(`cc at index ${ccIndex} in group ${realGroupIndex} removed.`);
            generateTable(decodedData); // Refresh table
        }

        document.getElementById("bandFilterInput").addEventListener("input", function() {
            bandFilter = this.value.trim(); // Update filter value
            generateTable(decodedData); // Regenerate the table immediately
        });

        function applyBandFilter(comboGroups) {
            if (!bandFilter) return comboGroups; // No filter applied

            // Trim any space and trailing "+" to avoid issues
            bandFilter = bandFilter.replace(/\s+/g, "").replace(/\+$/, "");

            // Parse filter bands and extract both band and optional bwClassDL
            let filterBands = bandFilter.split("+").map(band => bandParseStr(band)); // Convert "n78C" or similar

            // If no valid filter bands, return the full set of combos
            if (filterBands.length === 0) return comboGroups;

            return comboGroups.filter(group =>
                group.combo.some(combo => {
                    return filterBands.every(filterBand => 
                        combo.cc.some(ccItem => 
                            ccItem.band === filterBand.band && 
                            (filterBand.bwClassDL === 0 || ccItem.bwClassDL === filterBand.bwClassDL)
                        )
                    );
                })
            );
        }

        function updatePaginationControls(totalPages) {
            let paginationHTML = `
                <button onclick="changePage(-1000)" ${currentPage === 1 ? "disabled" : ""}>«</button>
                <button onclick="changePage(-1)" ${currentPage === 1 ? "disabled" : ""}>Prev</button>
                <span>${currentPage}/${totalPages}</span>
                <button onclick="changePage(1)" ${currentPage === totalPages ? "disabled" : ""}>Next</button>
                
                
            `;
            document.getElementById("pagination").innerHTML = paginationHTML;
        }

        function changePage(direction) {
            let totalPages = Math.ceil(filteredGroups.length / rowsPerPage);

            currentPage += direction;
            if (currentPage < 1) currentPage = 1;
            if (currentPage > totalPages) currentPage = totalPages;

            generateTable(decodedData);
            window.scrollTo({top: 0});
        }

        function createDropdownOptions(featureSetList, selectedValue, ran) {
            let optionsHTML = '';

            // NR
            if (ran === 0) {
                featureSetList.forEach((feature, index) => {
                let selected = (index + 1 === selectedValue) ? "selected" : '';

                // Mapping SCS Numerology to Frequency
                const scsMapping = { 1: "15kHz", 2: "30kHz", 3: "60kHz", 4: "120kHz", 5: "240kHz" };
                let scs = `${scsMapping[feature.maxScs] || "Unknown"}`;

                // Mapping MIMO Enum
                const mimoMapping = { 0: "Not Supported", 1: "2x2", 2: "4x4", 3: "8x8" };
                const mimoCbMapping = { 0: "Not Supported", 1: "No", 2: "Yes" };
                let mimo;
                if (feature.maxMimo !== undefined) {
                    mimo = `${mimoMapping[feature.maxMimo] || "Unknown"}`;
                } else if (feature.maxMimoCb !== undefined) {
                    mimo = `ULMIMO: ${mimoCbMapping[feature.maxMimoCb] || "Unknown"}`;
                } else {
                    mimo = "MIMO: Unknown";
                }

                // Bandwidth (Stored as is)
                let bw = `${feature.maxBw} MHz`;

                // Mapping Modulation Order
                const modMapping = { 0: "Not Supported", 1: "QAM64", 2: "QAM256" };
                let mod = `${modMapping[feature.maxModOrder] || "Unknown"}`;

                // 90MHz Support (Boolean)
                let ninety = `90MHz: ${feature.bw90MHzSupported ? "Y" : "N"}`;

                optionsHTML += `<option value="${index + 1}" ${selected}>${index + 1}: 
                    ${scs}, ${mimo}, ${bw}, ${mod}, ${ninety}
                </option>`;
            });
            // LTE
            } else if (ran > 0) {
                featureSetList.forEach((feature, index) => {
                    let selected = (index === selectedValue) ? "selected" : '';
                    let disabled = (index === 0) ? "selected disabled hidden" : '';
                    optionsHTML += `<option value="${index}" ${selected} ${disabled}>${feature}</option>`;
                });
            }
            

            return optionsHTML;
        }

        function updateFeatureId(groupIndex, comboIndex, ccIndex, featureType, newValue, ran) {
            let featureObj = decodedData.ComboGroups[groupIndex].combo[comboIndex].cc[ccIndex];
            newValue = parseInt(newValue, 10);

            // NR
            if (ran === 0) {
                // Split the feature type to get key if applicable
                const [feature, key] = featureType.split('.');
                if (key !== undefined) {
                    if (!featureObj[feature]) {
                        featureObj[feature] = {};
                    }
                    featureObj[feature][key] = Math.max(newValue, 0);
                } else {
                    featureObj[featureType] = newValue;
                }
            // LTE
            } else if (ran > 0) {
                // LTE DL
                if (featureType === 0) {
                    FeatureIndex = parseLteFeatureIndex( {mimo: newValue, count: featureObj.bwClassDL, ran: 1}).FeatureIndex;
                    featureObj.dlFeatureIndex = FeatureIndex;
                }
                // LTE UL
                if (featureType === 1) {
                    FeatureIndex = parseLteFeatureIndex( {mimo: newValue, count: featureObj.bwClassUL, ran: 2}).FeatureIndex;
                    featureObj.ulFeatureIndex = FeatureIndex;
                }
            }
           
            // Apply bwClassDL, bwClassUL, dlFeatureIndex, ulFeatureIndex logic
            updateDependentValues(featureObj, ran);

            //console.log("Updated Feature Object:", featureObj);
            generateTable(decodedData); // Refresh the table
        }

        function updateDependentValues(featureObj, ran) {
            let dlFeatureCount = featureObj.dlFeaturePerCCIds ? Object.keys(featureObj.dlFeaturePerCCIds).length : 0;
            let ulFeatureCount = featureObj.ulFeaturePerCCIds ? Object.keys(featureObj.ulFeaturePerCCIds).length : 0;

            // Fetch maxScs from the feature list
            let dlFeatureId = dlFeatureCount > 0 ? featureObj.dlFeaturePerCCIds[0] : 0;
            let ulFeatureId = ulFeatureCount > 0 ? featureObj.ulFeaturePerCCIds[0] : 0;
            
            let maxScs = decodedData.dlFeaturePerCCList?.[dlFeatureId - 1]?.maxScs || 0;
            let maxMimoCb = decodedData.ulFeaturePerCCList?.[ulFeatureId - 1]?.maxMimoCb || 0;

            // Set bwClassDL
            if (dlFeatureCount === 0) {
                featureObj.bwClassDL = 0;
            } else if (maxScs === 4) {
                featureObj.bwClassDL = dlFeatureCount === 1 ? 1 : dlFeatureCount + 5;
            } else {
                featureObj.bwClassDL = dlFeatureCount === 1 ? 1 : dlFeatureCount + 1;
            }

            // Set bwClassUL
            if (ulFeatureCount === 0) {
                featureObj.bwClassUL = 0;
            } else if (maxScs === 4) {
                featureObj.bwClassUL = ulFeatureCount === 1 ? 1 : ulFeatureCount + 5;
            } else {
                featureObj.bwClassUL = ulFeatureCount === 1 ? 1 : ulFeatureCount + 1;
            }

            // Set dlFeatureIndex
            if (maxScs !== 0) {
                featureObj.dlFeatureIndex = (maxScs === 4) ? 2 : 1;
            }
            if (dlFeatureCount === 0) featureObj.dlFeatureIndex = 0;

            // Set ulFeatureIndex based on maxMimoCb
            if (ran === 0) {
                featureObj.ulFeatureIndex = (maxMimoCb === 2) ? 2 : (ulFeatureCount > 0 ? 1 : 0);
            }
            
            // LTE DL
            if (ran === 1) {
                mimo = parseLteFeatureIndex( {FeatureIndex: featureObj.dlFeatureIndex, ran: 1}).mimo;
                FeatureIndex = parseLteFeatureIndex( { mimo: mimo, count: featureObj.bwClassDL, ran: 1}).FeatureIndex;
                featureObj.dlFeatureIndex = FeatureIndex;
            // LTE UL
            } else if (ran === 2) {
                mimo = parseLteFeatureIndex( {FeatureIndex: featureObj.ulFeatureIndex, ran: 2}).mimo;
                FeatureIndex = parseLteFeatureIndex( { mimo: mimo, count: featureObj.bwClassUL, ran: 2}).FeatureIndex;
                featureObj.ulFeatureIndex = FeatureIndex;
            }
        }

        // Function to add a new index to dlFeaturePerCCIds or ulFeaturePerCCIds
        function addFeaturePerCCId(groupIndex, comboIndex, ccIndex, featureType, ran) {
            console.log(`Adding new key to ${featureType} in group ${groupIndex}, combo ${comboIndex}, cc ${ccIndex}`);

            
            let featureObj = decodedData.ComboGroups[groupIndex].combo[comboIndex].cc[ccIndex];

            // Ensure correct type (convert object to Uint8Array if needed)
            if (!featureObj[featureType] || !(featureObj[featureType] instanceof Uint8Array)) {
                featureObj[featureType] = new Uint8Array(0); 
            }

            // Convert Uint8Array to array to modify
            let featureArray = Array.from(featureObj[featureType]);

            // If no previous element exists at this index, insert '1'
            if (featureArray.length === 0) {
                if (ran === 0) {
                    featureArray.push(1); // Insert '1' if the array is empty for nr
                } else if (ran > 0) {
                    featureArray.push(0); // Insert '0' if the array is empty for lte
                }
                
            } else {
                // If the feature already exists, push the same value
                const lastValue = featureArray[featureArray.length - 1];
                featureArray.push(lastValue); // Push the last value again
            }

            // Convert back to Uint8Array
            featureObj[featureType] = new Uint8Array(featureArray);

            // Recalculate all dependent values immediately
            updateDependentValues(featureObj, ran);

            //console.log("Updated Feature Object:", featureObj);
            generateTable(decodedData); // Refresh the table
        }

        // Function to remove the last added featurePerCCId index
        function removeFeaturePerCCId(groupIndex, comboIndex, ccIndex, featureType, ran) {
            console.log(`Removing last key from ${featureType} in group ${groupIndex}, combo ${comboIndex}, cc ${ccIndex}`);

            let featureObj = decodedData.ComboGroups[groupIndex].combo[comboIndex].cc[ccIndex];

            if (!featureObj[featureType] || !(featureObj[featureType] instanceof Uint8Array)) return;

            // Convert Uint8Array to array
            let featureArray = Array.from(featureObj[featureType]);

            // Remove last item
            featureArray.pop();

            // Convert back to Uint8Array or remove the object if empty
            featureObj[featureType] = featureArray.length > 0 ? new Uint8Array(featureArray) : undefined;

            // If ulFeaturePerCCIds is empty, delete it entirely
            if (featureType === 'ulFeaturePerCCIds' && !featureObj[featureType]) {
                delete featureObj.ulFeaturePerCCIds;
            }

            // Recalculate all dependent values immediately
            updateDependentValues(featureObj, ran);

            //console.log("Updated Feature Object:", featureObj);
            generateTable(decodedData); // Refresh the table
        }

        function removeCombo(realGroupIndex, localComboIndex) {
            decodedData.ComboGroups[realGroupIndex].combo.splice(localComboIndex, 1);

            // If a group has no combos left, remove the whole group
            if (decodedData.ComboGroups[realGroupIndex].combo.length === 0) {
                decodedData.ComboGroups.splice(realGroupIndex, 1);
            }
            console.log(`Combo group at index ${realGroupIndex} removed.`);
            generateTable(decodedData); // Refresh table
        }

        let bitMaskToggled = false; // Track toggle state
        function toggleBitMask() {
            bitMaskToggled = !bitMaskToggled; // Toggle state

            decodedData.ComboGroups.forEach(group => {
                group.combo.forEach(combo => {
                    if (combo.hasOwnProperty("bitMask")) {
                        combo.bitMask = bitMaskToggled ? 65535 : 0;
                    }
                });
            });

            // Wait for DOM to update, then change button text
            setTimeout(() => {
                let button = document.getElementById("bitMaskToggleBtn");
                if (button) {
                    button.textContent = bitMaskToggled ? "Apply BM 0 patch" : "Apply BM 65k patch";
                }
            }, 10); // Small delay to ensure it updates properly

            console.log(`All bitMask values set to ${bitMaskToggled ? 65535 : 0}`);
        }

        let integrityToggled = false; // Track toggle state
        function toggleIntegrity() {
            integrityToggled = !integrityToggled; // Toggle state
            
            // Check if the 'unknown' value exists at the root level
            if (decodedData.hasOwnProperty('unknown')) {
                // If 'unknown' exists, remove it
                delete decodedData.unknown;
                console.log("Unknown integrity field removed.");
            } else {
                // Otherwise, set 'unknown' to 750569868
                decodedData.unknown = 750569868;
                console.log("Unknown integrity value set to 750569868.");
            }

            // Update the button text based on the existence of 'unknown'
            setTimeout(() => {
                let button = document.getElementById("toggleIntegrityBtn");
                if (button) {
                    if (decodedData.hasOwnProperty('unknown')) {
                        button.textContent = "Integrity OFF"; // If 'unknown' exists, show "Integrity OFF"
                    } else {
                        button.textContent = "Integrity ON";  // If 'unknown' doesn't exist, show "Integrity ON"
                    }
                }
            }, 10); // Small delay to ensure it updates properly

            // Refresh the table with the updated data
            generateTable(decodedData);
        }

        function editFeatureSets(direction) {
            
            const container = document.getElementById('fsdirbtn');

            // 1 for Downlink, 2 for Uplink
            if (direction === 1) {
                container.firstElementChild.style.opacity = '';
                container.children[1].style.opacity = '50%';
                document.getElementById("jsonOutput").textContent = JSON.stringify(decodedData.dlFeaturePerCCList, null, 2);
            } else if (direction === 2) {
                container.children[1].style.opacity = '';
                container.firstElementChild.style.opacity = '50%';
                document.getElementById("jsonOutput").textContent = JSON.stringify(decodedData.ulFeaturePerCCList, null, 2);
            }

            // Hide json related and show fs related
            document.getElementById("jsonheaderOutput").style.display = "none";
            document.getElementById("fsdirbtn").style.display = "block";

            document.getElementById("jsonOutput").contentEditable = true;
            document.getElementById("jsonheaderOutput").contentEditable = false;
            document.getElementById("jsonModal").style.display = "block";

            document.getElementById("savebtn").onclick = function() {
                let editedFS = JSON.parse(document.getElementById("jsonOutput").textContent);
                if (direction === 1) {
                    decodedData.dlFeaturePerCCList = editedFS;
                } else if (direction === 2) {
                    decodedData.ulFeaturePerCCList = editedFS;
                }

                console.log("FS applied.");
                // Close the modal
                document.getElementById("jsonModal").style.display = "none";

                // Refresh the table with the updated data
                generateTable(decodedData); // Refresh the table with updated data
            }

        }

        function showJSON(realGroupIndex, localComboIndex) {
            let group = decodedData.ComboGroups[realGroupIndex];
            let combo = group.combo[localComboIndex];
            let comboheader = group.comboHeader;

            // Display the JSON content in editable format
            document.getElementById("jsonOutput").textContent = JSON.stringify(combo, null, 2);
            document.getElementById("jsonheaderOutput").textContent = JSON.stringify(comboheader, null, 2);

            // Enable content editing for the div
            document.getElementById("jsonOutput").contentEditable = true;
            document.getElementById("jsonheaderOutput").contentEditable = true;
            document.getElementById("jsonheaderOutput").style.display = "block";

            // Hide FeatureSet buttons for json view
            document.getElementById("fsdirbtn").style.display = "none";
            
            // Show the modal
            document.getElementById("jsonModal").style.display = "block";

            // Define the save button's functionality
            document.getElementById("savebtn").onclick = function() {
                try {
                    // Parse the edited JSON from the text content
                    let editedCombo = JSON.parse(document.getElementById("jsonOutput").textContent);
                    let editedComboHeader = JSON.parse(document.getElementById("jsonheaderOutput").textContent);

                    // Ensure that the editedCombo is correctly structured with 'cc' object containing the feature arrays
                    if (!editedCombo.cc) {
                        editedCombo.cc = []; // Initialize the 'cc' array if it doesn't exist
                    }

                    // Loop through the 'cc' array and check each feature
                    editedCombo.cc.forEach((ccItem) => {
                        // Ensure dlFeaturePerCCIds is Uint8Array if it exists
                        if (ccItem.dlFeaturePerCCIds && typeof ccItem.dlFeaturePerCCIds === 'object') {
                            const dlValues = Object.values(ccItem.dlFeaturePerCCIds);
                            ccItem.dlFeaturePerCCIds = new Uint8Array(dlValues);
                        }

                        // Ensure ulFeaturePerCCIds is Uint8Array if it exists
                        if (ccItem.ulFeaturePerCCIds && typeof ccItem.ulFeaturePerCCIds === 'object') {
                            const ulValues = Object.values(ccItem.ulFeaturePerCCIds);
                            ccItem.ulFeaturePerCCIds = new Uint8Array(ulValues);
                        }
                    });

                    // Update decodedData with the modified combo and combo header
                    group.combo[localComboIndex] = editedCombo;    // Update the specific combo
                    group.comboHeader = editedComboHeader;          // Update the combo header

                    console.log("JSON applied.");
                    // Close the modal
                    document.getElementById("jsonModal").style.display = "none";

                    // Refresh the table with the updated data
                    generateTable(decodedData); // Refresh the table with updated data

                } catch (error) {
                    console.error("Invalid JSON format:", error);
                    alert("Please ensure the JSON is valid.");
                }
            };
        }

        function closeModal() {
            document.getElementById("jsonModal").style.display = "none";
        }

        function showCustomFeatureModal() {
            document.getElementById("customFeatureModal").style.display = "block";
        }

        function closeCustomFeatureModal() {
            document.getElementById("customFeatureModal").style.display = "none";
        }

        function addCustomDlFeature() {
            if (!decodedData.dlFeaturePerCCList) {
                decodedData.dlFeaturePerCCList = [];
            }
    
            const newFeature = {
                maxScs: parseInt(document.getElementById("dlMaxScs").value),
                maxMimo: parseInt(document.getElementById("dlMaxMimo").value),
                maxBw: parseInt(document.getElementById("dlMaxBw").value),
                maxModOrder: parseInt(document.getElementById("dlMaxModOrder").value),
                bw90MHzSupported: document.getElementById("dlBw90MHz").checked
            };
    
            decodedData.dlFeaturePerCCList.push(newFeature);
    
            alert(`DL Feature added! Index: ${decodedData.dlFeaturePerCCList.length}`);
            generateTable(decodedData);
        }

        function addCustomUlFeature() {
            if (!decodedData.ulFeaturePerCCList) {
                decodedData.ulFeaturePerCCList = [];
            }
    
            const newFeature = {
                maxScs: parseInt(document.getElementById("ulMaxScs").value),
                maxMimoCb: parseInt(document.getElementById("ulMaxMimoCb").value),
                maxBw: parseInt(document.getElementById("ulMaxBw").value),
                maxModOrder: parseInt(document.getElementById("ulMaxModOrder").value),
                bw90MHzSupported: document.getElementById("ulBw90MHz").checked,
                maxMimoNonCb: parseInt(document.getElementById("ulMaxMimoNonCb").value)
            };
    
            decodedData.ulFeaturePerCCList.push(newFeature);
    
            alert(`UL Feature added! Index: ${decodedData.ulFeaturePerCCList.length}`);
            generateTable(decodedData);
        }

        // File handling and recompile functions
        let decodedData;
        let originalFilename;
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            originalFilename = file.name.endsWith(".binarypb") ? file.name.slice(0, -9) : file.name;
            
            document.getElementById("filenameInput").value = originalFilename || "default_filename";

            const reader = new FileReader();
            reader.onload = function(e) {
                const buffer = new Uint8Array(e.target.result);
                try {
                    const decodedMessage = UeCaps.decode(buffer);
                    decodedData = UeCaps.toObject(decodedMessage, { defaults: true });
                    processDecodedMessage(decodedData);
                    generateTable(decodedData);
                } catch (error) {
                    document.getElementById('tableContainer').innerHTML = "Error decoding file: " + error.message;
                }
            };
            reader.readAsArrayBuffer(file);
        });        

        function recompileProtobuf() {
            if (!decodedData) return alert("No data to recompile!");
            const message = UeCaps.fromObject(decodedData);
            //console.log("Compiling this:", JSON.stringify(message, null, 2));
            const buffer = UeCaps.encode(message).finish();
            return new Blob([buffer], { type: "application/octet-stream" });
        }

        function dlProtobuf() {
            const link = document.createElement("a");
            link.href = URL.createObjectURL(recompileProtobuf());
            link.download = `mod_${originalFilename}.binarypb`;
            link.click();
        }

        let clearSessionFlag = false;

        function clearLocalStorageAndReload() {
            // Set the flag to indicate that localStorage has been cleared
            clearSessionFlag = true;

            // Clear localStorage and sessionStorage
            localStorage.clear();
            sessionStorage.clear();

            // Reload the page
            location.reload();
        }

        function saveToLocalStorage() {
            if (clearSessionFlag) {
                // Do not save to localStorage if the flag is set
                clearSessionFlag = false; // Reset the flag after saving
                return;
            }

            const compressedBlob = recompileProtobuf(); // Get the binary protobuf data (Blob)
            
            // Convert the Blob to a Base64 string (as localStorage can only store strings)
            const reader = new FileReader();
            reader.onloadend = function() {
                const base64String = reader.result.split(',')[1]; // Strip out the "data:" prefix
                localStorage.setItem('protobufData', base64String); // Store the Base64 string in localStorage
                console.log("Data saved to localStorage.");
            };
            reader.readAsDataURL(compressedBlob); // Convert the Blob to a Base64 string
            localStorage.setItem('fileName', originalFilename);
        }

        function loadFromLocalStorage() {
            const base64String = localStorage.getItem('protobufData');
            const fileName = localStorage.getItem('fileName');
            if (!base64String) {
                console.log("No data found in localStorage.");
                return;
            }

            // Decode the Base64 string back to binary (Uint8Array)
            const binaryString = atob(base64String); // Decode the Base64 string to binary string
            const binaryArray = new Uint8Array(binaryString.length); // Create a Uint8Array to hold the binary data
            for (let i = 0; i < binaryString.length; i++) {
                binaryArray[i] = binaryString.charCodeAt(i); // Convert the binary string to a Uint8Array
            }
            originalFilename = fileName;
            // Update filename field
            document.getElementById("filenameInput").value = originalFilename || "default_filename";
            console.log(`${originalFilename} cache pb loaded from localStorage.`);
            // Decode the protobuf data using the decoded binary buffer
            try {
                const decodedMessage = UeCaps.decode(binaryArray);
                decodedData = UeCaps.toObject(decodedMessage, { defaults: true });
                processDecodedMessage(decodedData);
                generateTable(decodedData);
                console.log("Cache decoded successfully.");
            } catch (error) {
                console.error("Error loading or decoding data:", error);
            }
        }

        window.addEventListener('beforeunload', function() {
            //saveTableData(); // Save data before the page is closed or navigated away
            if (!clearSessionFlag) {
                saveToLocalStorage(); // Only save if the flag is not set
            }
        });

        window.addEventListener('load', function() {
            //loadTableData(); // Load saved data from localStorage when the page is loaded
            loadFromLocalStorage();
        });

        // Function to update filename
        function updateFilename(newName) {
            originalFilename = newName;
        }

        function getFormattedDate() {
            const now = new Date();
            return now.getFullYear() + '.' +
                String(now.getMonth() + 1).padStart(2, '0') + '.' +
                String(now.getDate()).padStart(2, '0') + '.' +
                String(now.getHours()).padStart(2, '0') + '.' +
                String(now.getMinutes()).padStart(2, '0');
        }
        
        async function createZipWithSubdirectories() {
            let curr_time = getFormattedDate();
            // Create a new ZIP instance
            const zip = new JSZip();
            
            // Create subdirectories
            const folder1 = zip.folder("META-INF/com/google/android");
            const folder2 = zip.folder("system/vendor/firmware/uecapconfig");
            
        
            // Magisk update-binary base64
            const sampleBase64 = "IyEvc2Jpbi9zaAoKIyMjIyMjIyMjIyMjIyMjIyMKIyBJbml0aWFsaXphdGlvbgojIyMjIyMjIyMjIyMjIyMjIwoKdW1hc2sgMDIyCgojIGVjaG8gYmVmb3JlIGxvYWRpbmcgdXRpbF9mdW5jdGlvbnMKdWlfcHJpbnQoKSB7IGVjaG8gIiQxIjsgfQoKcmVxdWlyZV9uZXdfbWFnaXNrKCkgewogIHVpX3ByaW50ICIqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIgogIHVpX3ByaW50ICIgUGxlYXNlIGluc3RhbGwgTWFnaXNrIHYyMC40KyEgIgogIHVpX3ByaW50ICIqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIgogIGV4aXQgMQp9CgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgTG9hZCB1dGlsX2Z1bmN0aW9ucy5zaAojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpPVVRGRD0kMgpaSVBGSUxFPSQzCgptb3VudCAvZGF0YSAyPi9kZXYvbnVsbAoKWyAtZiAvZGF0YS9hZGIvbWFnaXNrL3V0aWxfZnVuY3Rpb25zLnNoIF0gfHwgcmVxdWlyZV9uZXdfbWFnaXNrCi4gL2RhdGEvYWRiL21hZ2lzay91dGlsX2Z1bmN0aW9ucy5zaApbICRNQUdJU0tfVkVSX0NPREUgLWx0IDIwNDAwIF0gJiYgcmVxdWlyZV9uZXdfbWFnaXNrCgppbnN0YWxsX21vZHVsZQpleGl0IDAK";
            
            const customizesh_file = `set_perm_recursive $MODPATH 0 0 0755 0644`;
            const moduleprop_file = `id=PixelUecap
name=Pixel Uecapa mod
version=${curr_time}
versionCode=${(Date.now()).toString().slice(9)}
author=pixel-pb
description=Replaces ${originalFilename}. Generated with nxij.github.io/pixel-pb.`;

            // Convert base64 to binary
            const binaryData = atob(sampleBase64);
            
            // Convert binary string to Uint8Array
            const bytes = new Uint8Array(binaryData.length);
            for (let i = 0; i < binaryData.length; i++) {
                bytes[i] = binaryData.charCodeAt(i);
            }

            // Add files to different directories
            zip.file("customize.sh", customizesh_file, { unixPermissions: "644" });
            zip.file("module.prop", moduleprop_file, { unixPermissions: "644" });
            
            folder1.file("update-binary", bytes, { binary: true, unixPermissions: "644" });
            folder1.file("updater-script", "#MAGISK", { unixPermissions: "644" });

            folder2.file(`${originalFilename}.binarypb`, recompileProtobuf(), { unixPermissions: "644" });
            
            try {
                // Generate the ZIP file
                const content = await zip.generateAsync({
                    type: "blob",
                    platform: "UNIX",
                    compression: "DEFLATE",
                    compressionOptions: {
                        level: 9
                    }
                });
                
                // Create download link
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${originalFilename}-${curr_time}.zip`;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                
                // Cleanup
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                return true;
            } catch (error) {
                console.error('Error creating ZIP:', error);
                return false;
            }
        }
    </script>
</body>
</html>
